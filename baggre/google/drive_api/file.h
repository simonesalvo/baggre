// Copyright 2010 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

// This code was generated by google-apis-code-generator 1.5.0
//   Build date: 2014-10-28 17:08:27 UTC
//   on: 2014-10-30, 17:11:04 UTC
//   C++ generator version:

// ----------------------------------------------------------------------------
// NOTE: This file is generated from Google APIs Discovery Service.
// Service:
//   Drive API (drive/v2)
// Generated from:
//   Version: v2
//   Revision: 151
// Generated by:
//    Tool: google-apis-code-generator 1.5.0
//     C++: 0.1.2
#ifndef  GOOGLE_DRIVE_API_FILE_H_
#define  GOOGLE_DRIVE_API_FILE_H_

#include <string>
#include "googleapis/base/integral_types.h"
#include "googleapis/base/macros.h"
#include "googleapis/client/data/jsoncpp_data.h"
#include "googleapis/client/util/date_time.h"
#include "googleapis/strings/stringpiece.h"

#include "google/drive_api/parent_reference.h"
#include "google/drive_api/permission.h"
#include "google/drive_api/property.h"
#include "google/drive_api/user.h"

namespace Json {
class Value;
}  // namespace Json

namespace google_drive_api {
using namespace googleapis;

/**
 * The metadata for a file.
 *
 * @ingroup DataObject
 */
class File : public client::JsonCppData {
 public:

  /**
   * Metadata about image media. This will only be present for image types, and
   * its contents will depend on what can be parsed from the image content.
   *
   * @ingroup DataObject
   */
  class FileImageMediaMetadata : public client::JsonCppData {
   public:

    /**
     * Geographic location information stored in the image.
     *
     * @ingroup DataObject
     */
    class FileImageMediaMetadataLocation : public client::JsonCppData {
     public:

      /**
       * Creates a new default instance.
       *
       * @return Ownership is passed back to the caller.
       */
      static FileImageMediaMetadataLocation* New();

      /**
       * Standard constructor for an immutable data object instance.
       *
       * @param[in] storage  The underlying data storage for this instance.
       */
      explicit FileImageMediaMetadataLocation(const Json::Value& storage);

      /**
       * Standard constructor for a mutable data object instance.
       *
       * @param[in] storage  The underlying data storage for this instance.
       */
      explicit FileImageMediaMetadataLocation(Json::Value* storage);

      /**
       * Standard destructor.
       */
      virtual ~FileImageMediaMetadataLocation();

      /**
       * Returns a string denoting the type of this data object.
       *
       * @return <code>google_drive_api::FileImageMediaMetadataLocation</code>
       */
      const StringPiece GetTypeName() const {
        return StringPiece("google_drive_api::FileImageMediaMetadataLocation");
      }

      /**
       * Determine if the '<code>altitude</code>' attribute was set.
       *
       * @return true if the '<code>altitude</code>' attribute was set.
       */
      bool has_altitude() const {
        return Storage().isMember("altitude");
      }

      /**
       * Clears the '<code>altitude</code>' attribute.
       */
      void clear_altitude() {
        MutableStorage()->removeMember("altitude");
      }


      /**
       * Get the value of the '<code>altitude</code>' attribute.
       */
      double get_altitude() const {
        const Json::Value& storage = Storage("altitude");
        return client::JsonValueToCppValueHelper<double >(storage);
      }

      /**
       * Change the '<code>altitude</code>' attribute.
       *
       * The altitude stored in the image.
       *
       * @param[in] value The new value.
       */
      void set_altitude(double value) {
        client::SetJsonValueFromCppValueHelper<double >(
          value, MutableStorage("altitude"));
      }

      /**
       * Determine if the '<code>latitude</code>' attribute was set.
       *
       * @return true if the '<code>latitude</code>' attribute was set.
       */
      bool has_latitude() const {
        return Storage().isMember("latitude");
      }

      /**
       * Clears the '<code>latitude</code>' attribute.
       */
      void clear_latitude() {
        MutableStorage()->removeMember("latitude");
      }


      /**
       * Get the value of the '<code>latitude</code>' attribute.
       */
      double get_latitude() const {
        const Json::Value& storage = Storage("latitude");
        return client::JsonValueToCppValueHelper<double >(storage);
      }

      /**
       * Change the '<code>latitude</code>' attribute.
       *
       * The latitude stored in the image.
       *
       * @param[in] value The new value.
       */
      void set_latitude(double value) {
        client::SetJsonValueFromCppValueHelper<double >(
          value, MutableStorage("latitude"));
      }

      /**
       * Determine if the '<code>longitude</code>' attribute was set.
       *
       * @return true if the '<code>longitude</code>' attribute was set.
       */
      bool has_longitude() const {
        return Storage().isMember("longitude");
      }

      /**
       * Clears the '<code>longitude</code>' attribute.
       */
      void clear_longitude() {
        MutableStorage()->removeMember("longitude");
      }


      /**
       * Get the value of the '<code>longitude</code>' attribute.
       */
      double get_longitude() const {
        const Json::Value& storage = Storage("longitude");
        return client::JsonValueToCppValueHelper<double >(storage);
      }

      /**
       * Change the '<code>longitude</code>' attribute.
       *
       * The longitude stored in the image.
       *
       * @param[in] value The new value.
       */
      void set_longitude(double value) {
        client::SetJsonValueFromCppValueHelper<double >(
          value, MutableStorage("longitude"));
      }

     private:
      void operator=(const FileImageMediaMetadataLocation&);
    };  // FileImageMediaMetadataLocation
    /**
     * Creates a new default instance.
     *
     * @return Ownership is passed back to the caller.
     */
    static FileImageMediaMetadata* New();

    /**
     * Standard constructor for an immutable data object instance.
     *
     * @param[in] storage  The underlying data storage for this instance.
     */
    explicit FileImageMediaMetadata(const Json::Value& storage);

    /**
     * Standard constructor for a mutable data object instance.
     *
     * @param[in] storage  The underlying data storage for this instance.
     */
    explicit FileImageMediaMetadata(Json::Value* storage);

    /**
     * Standard destructor.
     */
    virtual ~FileImageMediaMetadata();

    /**
     * Returns a string denoting the type of this data object.
     *
     * @return <code>google_drive_api::FileImageMediaMetadata</code>
     */
    const StringPiece GetTypeName() const {
      return StringPiece("google_drive_api::FileImageMediaMetadata");
    }

    /**
     * Determine if the '<code>aperture</code>' attribute was set.
     *
     * @return true if the '<code>aperture</code>' attribute was set.
     */
    bool has_aperture() const {
      return Storage().isMember("aperture");
    }

    /**
     * Clears the '<code>aperture</code>' attribute.
     */
    void clear_aperture() {
      MutableStorage()->removeMember("aperture");
    }


    /**
     * Get the value of the '<code>aperture</code>' attribute.
     */
    float get_aperture() const {
      const Json::Value& storage = Storage("aperture");
      return client::JsonValueToCppValueHelper<float >(storage);
    }

    /**
     * Change the '<code>aperture</code>' attribute.
     *
     * The aperture used to create the photo (f-number).
     *
     * @param[in] value The new value.
     */
    void set_aperture(float value) {
      client::SetJsonValueFromCppValueHelper<float >(
        value, MutableStorage("aperture"));
    }

    /**
     * Determine if the '<code>cameraMake</code>' attribute was set.
     *
     * @return true if the '<code>cameraMake</code>' attribute was set.
     */
    bool has_camera_make() const {
      return Storage().isMember("cameraMake");
    }

    /**
     * Clears the '<code>cameraMake</code>' attribute.
     */
    void clear_camera_make() {
      MutableStorage()->removeMember("cameraMake");
    }


    /**
     * Get the value of the '<code>cameraMake</code>' attribute.
     */
    const StringPiece get_camera_make() const {
      const Json::Value& v = Storage("cameraMake");
      if (v == Json::Value::null) return StringPiece("");
      return StringPiece(v.asCString());
    }

    /**
     * Change the '<code>cameraMake</code>' attribute.
     *
     * The make of the camera used to create the photo.
     *
     * @param[in] value The new value.
     */
    void set_camera_make(const StringPiece& value) {
      *MutableStorage("cameraMake") = value.data();
    }

    /**
     * Determine if the '<code>cameraModel</code>' attribute was set.
     *
     * @return true if the '<code>cameraModel</code>' attribute was set.
     */
    bool has_camera_model() const {
      return Storage().isMember("cameraModel");
    }

    /**
     * Clears the '<code>cameraModel</code>' attribute.
     */
    void clear_camera_model() {
      MutableStorage()->removeMember("cameraModel");
    }


    /**
     * Get the value of the '<code>cameraModel</code>' attribute.
     */
    const StringPiece get_camera_model() const {
      const Json::Value& v = Storage("cameraModel");
      if (v == Json::Value::null) return StringPiece("");
      return StringPiece(v.asCString());
    }

    /**
     * Change the '<code>cameraModel</code>' attribute.
     *
     * The model of the camera used to create the photo.
     *
     * @param[in] value The new value.
     */
    void set_camera_model(const StringPiece& value) {
      *MutableStorage("cameraModel") = value.data();
    }

    /**
     * Determine if the '<code>colorSpace</code>' attribute was set.
     *
     * @return true if the '<code>colorSpace</code>' attribute was set.
     */
    bool has_color_space() const {
      return Storage().isMember("colorSpace");
    }

    /**
     * Clears the '<code>colorSpace</code>' attribute.
     */
    void clear_color_space() {
      MutableStorage()->removeMember("colorSpace");
    }


    /**
     * Get the value of the '<code>colorSpace</code>' attribute.
     */
    const StringPiece get_color_space() const {
      const Json::Value& v = Storage("colorSpace");
      if (v == Json::Value::null) return StringPiece("");
      return StringPiece(v.asCString());
    }

    /**
     * Change the '<code>colorSpace</code>' attribute.
     *
     * The color space of the photo.
     *
     * @param[in] value The new value.
     */
    void set_color_space(const StringPiece& value) {
      *MutableStorage("colorSpace") = value.data();
    }

    /**
     * Determine if the '<code>date</code>' attribute was set.
     *
     * @return true if the '<code>date</code>' attribute was set.
     */
    bool has_date() const {
      return Storage().isMember("date");
    }

    /**
     * Clears the '<code>date</code>' attribute.
     */
    void clear_date() {
      MutableStorage()->removeMember("date");
    }


    /**
     * Get the value of the '<code>date</code>' attribute.
     */
    const StringPiece get_date() const {
      const Json::Value& v = Storage("date");
      if (v == Json::Value::null) return StringPiece("");
      return StringPiece(v.asCString());
    }

    /**
     * Change the '<code>date</code>' attribute.
     *
     * The date and time the photo was taken (EXIF format timestamp).
     *
     * @param[in] value The new value.
     */
    void set_date(const StringPiece& value) {
      *MutableStorage("date") = value.data();
    }

    /**
     * Determine if the '<code>exposureBias</code>' attribute was set.
     *
     * @return true if the '<code>exposureBias</code>' attribute was set.
     */
    bool has_exposure_bias() const {
      return Storage().isMember("exposureBias");
    }

    /**
     * Clears the '<code>exposureBias</code>' attribute.
     */
    void clear_exposure_bias() {
      MutableStorage()->removeMember("exposureBias");
    }


    /**
     * Get the value of the '<code>exposureBias</code>' attribute.
     */
    float get_exposure_bias() const {
      const Json::Value& storage = Storage("exposureBias");
      return client::JsonValueToCppValueHelper<float >(storage);
    }

    /**
     * Change the '<code>exposureBias</code>' attribute.
     *
     * The exposure bias of the photo (APEX value).
     *
     * @param[in] value The new value.
     */
    void set_exposure_bias(float value) {
      client::SetJsonValueFromCppValueHelper<float >(
        value, MutableStorage("exposureBias"));
    }

    /**
     * Determine if the '<code>exposureMode</code>' attribute was set.
     *
     * @return true if the '<code>exposureMode</code>' attribute was set.
     */
    bool has_exposure_mode() const {
      return Storage().isMember("exposureMode");
    }

    /**
     * Clears the '<code>exposureMode</code>' attribute.
     */
    void clear_exposure_mode() {
      MutableStorage()->removeMember("exposureMode");
    }


    /**
     * Get the value of the '<code>exposureMode</code>' attribute.
     */
    const StringPiece get_exposure_mode() const {
      const Json::Value& v = Storage("exposureMode");
      if (v == Json::Value::null) return StringPiece("");
      return StringPiece(v.asCString());
    }

    /**
     * Change the '<code>exposureMode</code>' attribute.
     *
     * The exposure mode used to create the photo.
     *
     * @param[in] value The new value.
     */
    void set_exposure_mode(const StringPiece& value) {
      *MutableStorage("exposureMode") = value.data();
    }

    /**
     * Determine if the '<code>exposureTime</code>' attribute was set.
     *
     * @return true if the '<code>exposureTime</code>' attribute was set.
     */
    bool has_exposure_time() const {
      return Storage().isMember("exposureTime");
    }

    /**
     * Clears the '<code>exposureTime</code>' attribute.
     */
    void clear_exposure_time() {
      MutableStorage()->removeMember("exposureTime");
    }


    /**
     * Get the value of the '<code>exposureTime</code>' attribute.
     */
    float get_exposure_time() const {
      const Json::Value& storage = Storage("exposureTime");
      return client::JsonValueToCppValueHelper<float >(storage);
    }

    /**
     * Change the '<code>exposureTime</code>' attribute.
     *
     * The length of the exposure, in seconds.
     *
     * @param[in] value The new value.
     */
    void set_exposure_time(float value) {
      client::SetJsonValueFromCppValueHelper<float >(
        value, MutableStorage("exposureTime"));
    }

    /**
     * Determine if the '<code>flashUsed</code>' attribute was set.
     *
     * @return true if the '<code>flashUsed</code>' attribute was set.
     */
    bool has_flash_used() const {
      return Storage().isMember("flashUsed");
    }

    /**
     * Clears the '<code>flashUsed</code>' attribute.
     */
    void clear_flash_used() {
      MutableStorage()->removeMember("flashUsed");
    }


    /**
     * Get the value of the '<code>flashUsed</code>' attribute.
     */
    bool get_flash_used() const {
      const Json::Value& storage = Storage("flashUsed");
      return client::JsonValueToCppValueHelper<bool >(storage);
    }

    /**
     * Change the '<code>flashUsed</code>' attribute.
     *
     * Whether a flash was used to create the photo.
     *
     * @param[in] value The new value.
     */
    void set_flash_used(bool value) {
      client::SetJsonValueFromCppValueHelper<bool >(
        value, MutableStorage("flashUsed"));
    }

    /**
     * Determine if the '<code>focalLength</code>' attribute was set.
     *
     * @return true if the '<code>focalLength</code>' attribute was set.
     */
    bool has_focal_length() const {
      return Storage().isMember("focalLength");
    }

    /**
     * Clears the '<code>focalLength</code>' attribute.
     */
    void clear_focal_length() {
      MutableStorage()->removeMember("focalLength");
    }


    /**
     * Get the value of the '<code>focalLength</code>' attribute.
     */
    float get_focal_length() const {
      const Json::Value& storage = Storage("focalLength");
      return client::JsonValueToCppValueHelper<float >(storage);
    }

    /**
     * Change the '<code>focalLength</code>' attribute.
     *
     * The focal length used to create the photo, in millimeters.
     *
     * @param[in] value The new value.
     */
    void set_focal_length(float value) {
      client::SetJsonValueFromCppValueHelper<float >(
        value, MutableStorage("focalLength"));
    }

    /**
     * Determine if the '<code>height</code>' attribute was set.
     *
     * @return true if the '<code>height</code>' attribute was set.
     */
    bool has_height() const {
      return Storage().isMember("height");
    }

    /**
     * Clears the '<code>height</code>' attribute.
     */
    void clear_height() {
      MutableStorage()->removeMember("height");
    }


    /**
     * Get the value of the '<code>height</code>' attribute.
     */
    int32 get_height() const {
      const Json::Value& storage = Storage("height");
      return client::JsonValueToCppValueHelper<int32 >(storage);
    }

    /**
     * Change the '<code>height</code>' attribute.
     *
     * The height of the image in pixels.
     *
     * @param[in] value The new value.
     */
    void set_height(int32 value) {
      client::SetJsonValueFromCppValueHelper<int32 >(
        value, MutableStorage("height"));
    }

    /**
     * Determine if the '<code>isoSpeed</code>' attribute was set.
     *
     * @return true if the '<code>isoSpeed</code>' attribute was set.
     */
    bool has_iso_speed() const {
      return Storage().isMember("isoSpeed");
    }

    /**
     * Clears the '<code>isoSpeed</code>' attribute.
     */
    void clear_iso_speed() {
      MutableStorage()->removeMember("isoSpeed");
    }


    /**
     * Get the value of the '<code>isoSpeed</code>' attribute.
     */
    int32 get_iso_speed() const {
      const Json::Value& storage = Storage("isoSpeed");
      return client::JsonValueToCppValueHelper<int32 >(storage);
    }

    /**
     * Change the '<code>isoSpeed</code>' attribute.
     *
     * The ISO speed used to create the photo.
     *
     * @param[in] value The new value.
     */
    void set_iso_speed(int32 value) {
      client::SetJsonValueFromCppValueHelper<int32 >(
        value, MutableStorage("isoSpeed"));
    }

    /**
     * Determine if the '<code>lens</code>' attribute was set.
     *
     * @return true if the '<code>lens</code>' attribute was set.
     */
    bool has_lens() const {
      return Storage().isMember("lens");
    }

    /**
     * Clears the '<code>lens</code>' attribute.
     */
    void clear_lens() {
      MutableStorage()->removeMember("lens");
    }


    /**
     * Get the value of the '<code>lens</code>' attribute.
     */
    const StringPiece get_lens() const {
      const Json::Value& v = Storage("lens");
      if (v == Json::Value::null) return StringPiece("");
      return StringPiece(v.asCString());
    }

    /**
     * Change the '<code>lens</code>' attribute.
     *
     * The lens used to create the photo.
     *
     * @param[in] value The new value.
     */
    void set_lens(const StringPiece& value) {
      *MutableStorage("lens") = value.data();
    }

    /**
     * Determine if the '<code>location</code>' attribute was set.
     *
     * @return true if the '<code>location</code>' attribute was set.
     */
    bool has_location() const {
      return Storage().isMember("location");
    }

    /**
     * Clears the '<code>location</code>' attribute.
     */
    void clear_location() {
      MutableStorage()->removeMember("location");
    }


    /**
     * Get a reference to the value of the '<code>location</code>' attribute.
     */
    const FileImageMediaMetadataLocation get_location() const {
       const Json::Value& storage = Storage("location");
      return client::JsonValueToCppValueHelper<FileImageMediaMetadataLocation >(storage);
    }

    /**
     * Gets a reference to a mutable value of the '<code>location</code>'
     * property.
     *
     * Geographic location information stored in the image.
     *
     * @return The result can be modified to change the attribute value.
     */
    FileImageMediaMetadataLocation mutable_location() {
      Json::Value* storage = MutableStorage("location");
      return client::JsonValueToMutableCppValueHelper<FileImageMediaMetadataLocation >(storage);
    }

    /**
     * Determine if the '<code>maxApertureValue</code>' attribute was set.
     *
     * @return true if the '<code>maxApertureValue</code>' attribute was set.
     */
    bool has_max_aperture_value() const {
      return Storage().isMember("maxApertureValue");
    }

    /**
     * Clears the '<code>maxApertureValue</code>' attribute.
     */
    void clear_max_aperture_value() {
      MutableStorage()->removeMember("maxApertureValue");
    }


    /**
     * Get the value of the '<code>maxApertureValue</code>' attribute.
     */
    float get_max_aperture_value() const {
      const Json::Value& storage = Storage("maxApertureValue");
      return client::JsonValueToCppValueHelper<float >(storage);
    }

    /**
     * Change the '<code>maxApertureValue</code>' attribute.
     *
     * The smallest f-number of the lens at the focal length used to create the
     * photo (APEX value).
     *
     * @param[in] value The new value.
     */
    void set_max_aperture_value(float value) {
      client::SetJsonValueFromCppValueHelper<float >(
        value, MutableStorage("maxApertureValue"));
    }

    /**
     * Determine if the '<code>meteringMode</code>' attribute was set.
     *
     * @return true if the '<code>meteringMode</code>' attribute was set.
     */
    bool has_metering_mode() const {
      return Storage().isMember("meteringMode");
    }

    /**
     * Clears the '<code>meteringMode</code>' attribute.
     */
    void clear_metering_mode() {
      MutableStorage()->removeMember("meteringMode");
    }


    /**
     * Get the value of the '<code>meteringMode</code>' attribute.
     */
    const StringPiece get_metering_mode() const {
      const Json::Value& v = Storage("meteringMode");
      if (v == Json::Value::null) return StringPiece("");
      return StringPiece(v.asCString());
    }

    /**
     * Change the '<code>meteringMode</code>' attribute.
     *
     * The metering mode used to create the photo.
     *
     * @param[in] value The new value.
     */
    void set_metering_mode(const StringPiece& value) {
      *MutableStorage("meteringMode") = value.data();
    }

    /**
     * Determine if the '<code>rotation</code>' attribute was set.
     *
     * @return true if the '<code>rotation</code>' attribute was set.
     */
    bool has_rotation() const {
      return Storage().isMember("rotation");
    }

    /**
     * Clears the '<code>rotation</code>' attribute.
     */
    void clear_rotation() {
      MutableStorage()->removeMember("rotation");
    }


    /**
     * Get the value of the '<code>rotation</code>' attribute.
     */
    int32 get_rotation() const {
      const Json::Value& storage = Storage("rotation");
      return client::JsonValueToCppValueHelper<int32 >(storage);
    }

    /**
     * Change the '<code>rotation</code>' attribute.
     *
     * The rotation in clockwise degrees from the image's original orientation.
     *
     * @param[in] value The new value.
     */
    void set_rotation(int32 value) {
      client::SetJsonValueFromCppValueHelper<int32 >(
        value, MutableStorage("rotation"));
    }

    /**
     * Determine if the '<code>sensor</code>' attribute was set.
     *
     * @return true if the '<code>sensor</code>' attribute was set.
     */
    bool has_sensor() const {
      return Storage().isMember("sensor");
    }

    /**
     * Clears the '<code>sensor</code>' attribute.
     */
    void clear_sensor() {
      MutableStorage()->removeMember("sensor");
    }


    /**
     * Get the value of the '<code>sensor</code>' attribute.
     */
    const StringPiece get_sensor() const {
      const Json::Value& v = Storage("sensor");
      if (v == Json::Value::null) return StringPiece("");
      return StringPiece(v.asCString());
    }

    /**
     * Change the '<code>sensor</code>' attribute.
     *
     * The type of sensor used to create the photo.
     *
     * @param[in] value The new value.
     */
    void set_sensor(const StringPiece& value) {
      *MutableStorage("sensor") = value.data();
    }

    /**
     * Determine if the '<code>subjectDistance</code>' attribute was set.
     *
     * @return true if the '<code>subjectDistance</code>' attribute was set.
     */
    bool has_subject_distance() const {
      return Storage().isMember("subjectDistance");
    }

    /**
     * Clears the '<code>subjectDistance</code>' attribute.
     */
    void clear_subject_distance() {
      MutableStorage()->removeMember("subjectDistance");
    }


    /**
     * Get the value of the '<code>subjectDistance</code>' attribute.
     */
    int32 get_subject_distance() const {
      const Json::Value& storage = Storage("subjectDistance");
      return client::JsonValueToCppValueHelper<int32 >(storage);
    }

    /**
     * Change the '<code>subjectDistance</code>' attribute.
     *
     * The distance to the subject of the photo, in meters.
     *
     * @param[in] value The new value.
     */
    void set_subject_distance(int32 value) {
      client::SetJsonValueFromCppValueHelper<int32 >(
        value, MutableStorage("subjectDistance"));
    }

    /**
     * Determine if the '<code>whiteBalance</code>' attribute was set.
     *
     * @return true if the '<code>whiteBalance</code>' attribute was set.
     */
    bool has_white_balance() const {
      return Storage().isMember("whiteBalance");
    }

    /**
     * Clears the '<code>whiteBalance</code>' attribute.
     */
    void clear_white_balance() {
      MutableStorage()->removeMember("whiteBalance");
    }


    /**
     * Get the value of the '<code>whiteBalance</code>' attribute.
     */
    const StringPiece get_white_balance() const {
      const Json::Value& v = Storage("whiteBalance");
      if (v == Json::Value::null) return StringPiece("");
      return StringPiece(v.asCString());
    }

    /**
     * Change the '<code>whiteBalance</code>' attribute.
     *
     * The white balance mode used to create the photo.
     *
     * @param[in] value The new value.
     */
    void set_white_balance(const StringPiece& value) {
      *MutableStorage("whiteBalance") = value.data();
    }

    /**
     * Determine if the '<code>width</code>' attribute was set.
     *
     * @return true if the '<code>width</code>' attribute was set.
     */
    bool has_width() const {
      return Storage().isMember("width");
    }

    /**
     * Clears the '<code>width</code>' attribute.
     */
    void clear_width() {
      MutableStorage()->removeMember("width");
    }


    /**
     * Get the value of the '<code>width</code>' attribute.
     */
    int32 get_width() const {
      const Json::Value& storage = Storage("width");
      return client::JsonValueToCppValueHelper<int32 >(storage);
    }

    /**
     * Change the '<code>width</code>' attribute.
     *
     * The width of the image in pixels.
     *
     * @param[in] value The new value.
     */
    void set_width(int32 value) {
      client::SetJsonValueFromCppValueHelper<int32 >(
        value, MutableStorage("width"));
    }

   private:
    void operator=(const FileImageMediaMetadata&);
  };  // FileImageMediaMetadata
  /**
   * Indexable text attributes for the file (can only be written).
   *
   * @ingroup DataObject
   */
  class FileIndexableText : public client::JsonCppData {
   public:

    /**
     * Creates a new default instance.
     *
     * @return Ownership is passed back to the caller.
     */
    static FileIndexableText* New();

    /**
     * Standard constructor for an immutable data object instance.
     *
     * @param[in] storage  The underlying data storage for this instance.
     */
    explicit FileIndexableText(const Json::Value& storage);

    /**
     * Standard constructor for a mutable data object instance.
     *
     * @param[in] storage  The underlying data storage for this instance.
     */
    explicit FileIndexableText(Json::Value* storage);

    /**
     * Standard destructor.
     */
    virtual ~FileIndexableText();

    /**
     * Returns a string denoting the type of this data object.
     *
     * @return <code>google_drive_api::FileIndexableText</code>
     */
    const StringPiece GetTypeName() const {
      return StringPiece("google_drive_api::FileIndexableText");
    }

    /**
     * Determine if the '<code>text</code>' attribute was set.
     *
     * @return true if the '<code>text</code>' attribute was set.
     */
    bool has_text() const {
      return Storage().isMember("text");
    }

    /**
     * Clears the '<code>text</code>' attribute.
     */
    void clear_text() {
      MutableStorage()->removeMember("text");
    }


    /**
     * Get the value of the '<code>text</code>' attribute.
     */
    const StringPiece get_text() const {
      const Json::Value& v = Storage("text");
      if (v == Json::Value::null) return StringPiece("");
      return StringPiece(v.asCString());
    }

    /**
     * Change the '<code>text</code>' attribute.
     *
     * The text to be indexed for this file.
     *
     * @param[in] value The new value.
     */
    void set_text(const StringPiece& value) {
      *MutableStorage("text") = value.data();
    }

   private:
    void operator=(const FileIndexableText&);
  };  // FileIndexableText
  /**
   * A group of labels for the file.
   *
   * @ingroup DataObject
   */
  class FileLabels : public client::JsonCppData {
   public:

    /**
     * Creates a new default instance.
     *
     * @return Ownership is passed back to the caller.
     */
    static FileLabels* New();

    /**
     * Standard constructor for an immutable data object instance.
     *
     * @param[in] storage  The underlying data storage for this instance.
     */
    explicit FileLabels(const Json::Value& storage);

    /**
     * Standard constructor for a mutable data object instance.
     *
     * @param[in] storage  The underlying data storage for this instance.
     */
    explicit FileLabels(Json::Value* storage);

    /**
     * Standard destructor.
     */
    virtual ~FileLabels();

    /**
     * Returns a string denoting the type of this data object.
     *
     * @return <code>google_drive_api::FileLabels</code>
     */
    const StringPiece GetTypeName() const {
      return StringPiece("google_drive_api::FileLabels");
    }

    /**
     * Determine if the '<code>hidden</code>' attribute was set.
     *
     * @return true if the '<code>hidden</code>' attribute was set.
     */
    bool has_hidden() const {
      return Storage().isMember("hidden");
    }

    /**
     * Clears the '<code>hidden</code>' attribute.
     */
    void clear_hidden() {
      MutableStorage()->removeMember("hidden");
    }


    /**
     * Get the value of the '<code>hidden</code>' attribute.
     */
    bool get_hidden() const {
      const Json::Value& storage = Storage("hidden");
      return client::JsonValueToCppValueHelper<bool >(storage);
    }

    /**
     * Change the '<code>hidden</code>' attribute.
     * @deprecated
     *
     *
     * Deprecated.
     *
     * @param[in] value The new value.
     */
    void set_hidden(bool value) {
      client::SetJsonValueFromCppValueHelper<bool >(
        value, MutableStorage("hidden"));
    }

    /**
     * Determine if the '<code>restricted</code>' attribute was set.
     *
     * @return true if the '<code>restricted</code>' attribute was set.
     */
    bool has_restricted() const {
      return Storage().isMember("restricted");
    }

    /**
     * Clears the '<code>restricted</code>' attribute.
     */
    void clear_restricted() {
      MutableStorage()->removeMember("restricted");
    }


    /**
     * Get the value of the '<code>restricted</code>' attribute.
     */
    bool get_restricted() const {
      const Json::Value& storage = Storage("restricted");
      return client::JsonValueToCppValueHelper<bool >(storage);
    }

    /**
     * Change the '<code>restricted</code>' attribute.
     *
     * Whether viewers are prevented from downloading this file.
     *
     * @param[in] value The new value.
     */
    void set_restricted(bool value) {
      client::SetJsonValueFromCppValueHelper<bool >(
        value, MutableStorage("restricted"));
    }

    /**
     * Determine if the '<code>starred</code>' attribute was set.
     *
     * @return true if the '<code>starred</code>' attribute was set.
     */
    bool has_starred() const {
      return Storage().isMember("starred");
    }

    /**
     * Clears the '<code>starred</code>' attribute.
     */
    void clear_starred() {
      MutableStorage()->removeMember("starred");
    }


    /**
     * Get the value of the '<code>starred</code>' attribute.
     */
    bool get_starred() const {
      const Json::Value& storage = Storage("starred");
      return client::JsonValueToCppValueHelper<bool >(storage);
    }

    /**
     * Change the '<code>starred</code>' attribute.
     *
     * Whether this file is starred by the user.
     *
     * @param[in] value The new value.
     */
    void set_starred(bool value) {
      client::SetJsonValueFromCppValueHelper<bool >(
        value, MutableStorage("starred"));
    }

    /**
     * Determine if the '<code>trashed</code>' attribute was set.
     *
     * @return true if the '<code>trashed</code>' attribute was set.
     */
    bool has_trashed() const {
      return Storage().isMember("trashed");
    }

    /**
     * Clears the '<code>trashed</code>' attribute.
     */
    void clear_trashed() {
      MutableStorage()->removeMember("trashed");
    }


    /**
     * Get the value of the '<code>trashed</code>' attribute.
     */
    bool get_trashed() const {
      const Json::Value& storage = Storage("trashed");
      return client::JsonValueToCppValueHelper<bool >(storage);
    }

    /**
     * Change the '<code>trashed</code>' attribute.
     *
     * Whether this file has been trashed.
     *
     * @param[in] value The new value.
     */
    void set_trashed(bool value) {
      client::SetJsonValueFromCppValueHelper<bool >(
        value, MutableStorage("trashed"));
    }

    /**
     * Determine if the '<code>viewed</code>' attribute was set.
     *
     * @return true if the '<code>viewed</code>' attribute was set.
     */
    bool has_viewed() const {
      return Storage().isMember("viewed");
    }

    /**
     * Clears the '<code>viewed</code>' attribute.
     */
    void clear_viewed() {
      MutableStorage()->removeMember("viewed");
    }


    /**
     * Get the value of the '<code>viewed</code>' attribute.
     */
    bool get_viewed() const {
      const Json::Value& storage = Storage("viewed");
      return client::JsonValueToCppValueHelper<bool >(storage);
    }

    /**
     * Change the '<code>viewed</code>' attribute.
     *
     * Whether this file has been viewed by this user.
     *
     * @param[in] value The new value.
     */
    void set_viewed(bool value) {
      client::SetJsonValueFromCppValueHelper<bool >(
        value, MutableStorage("viewed"));
    }

   private:
    void operator=(const FileLabels&);
  };  // FileLabels
  /**
   * Thumbnail for the file. Only accepted on upload and for files that are not
   * already thumbnailed by Google.
   *
   * @ingroup DataObject
   */
  class FileThumbnail : public client::JsonCppData {
   public:

    /**
     * Creates a new default instance.
     *
     * @return Ownership is passed back to the caller.
     */
    static FileThumbnail* New();

    /**
     * Standard constructor for an immutable data object instance.
     *
     * @param[in] storage  The underlying data storage for this instance.
     */
    explicit FileThumbnail(const Json::Value& storage);

    /**
     * Standard constructor for a mutable data object instance.
     *
     * @param[in] storage  The underlying data storage for this instance.
     */
    explicit FileThumbnail(Json::Value* storage);

    /**
     * Standard destructor.
     */
    virtual ~FileThumbnail();

    /**
     * Returns a string denoting the type of this data object.
     *
     * @return <code>google_drive_api::FileThumbnail</code>
     */
    const StringPiece GetTypeName() const {
      return StringPiece("google_drive_api::FileThumbnail");
    }

    /**
     * Determine if the '<code>image</code>' attribute was set.
     *
     * @return true if the '<code>image</code>' attribute was set.
     */
    bool has_image() const {
      return Storage().isMember("image");
    }

    /**
     * Clears the '<code>image</code>' attribute.
     */
    void clear_image() {
      MutableStorage()->removeMember("image");
    }


    /**
     * Get the value of the '<code>image</code>' attribute.
     */
    const StringPiece get_image() const {
      const Json::Value& v = Storage("image");
      if (v == Json::Value::null) return StringPiece("");
      return StringPiece(v.asCString());
    }

    /**
     * Change the '<code>image</code>' attribute.
     *
     * The URL-safe Base64 encoded bytes of the thumbnail image.
     *
     * @param[in] value The new value.
     */
    void set_image(const StringPiece& value) {
      *MutableStorage("image") = value.data();
    }

    /**
     * Determine if the '<code>mimeType</code>' attribute was set.
     *
     * @return true if the '<code>mimeType</code>' attribute was set.
     */
    bool has_mime_type() const {
      return Storage().isMember("mimeType");
    }

    /**
     * Clears the '<code>mimeType</code>' attribute.
     */
    void clear_mime_type() {
      MutableStorage()->removeMember("mimeType");
    }


    /**
     * Get the value of the '<code>mimeType</code>' attribute.
     */
    const StringPiece get_mime_type() const {
      const Json::Value& v = Storage("mimeType");
      if (v == Json::Value::null) return StringPiece("");
      return StringPiece(v.asCString());
    }

    /**
     * Change the '<code>mimeType</code>' attribute.
     *
     * The MIME type of the thumbnail.
     *
     * @param[in] value The new value.
     */
    void set_mime_type(const StringPiece& value) {
      *MutableStorage("mimeType") = value.data();
    }

   private:
    void operator=(const FileThumbnail&);
  };  // FileThumbnail
  /**
   * Metadata about video media. This will only be present for video types.
   *
   * @ingroup DataObject
   */
  class FileVideoMediaMetadata : public client::JsonCppData {
   public:

    /**
     * Creates a new default instance.
     *
     * @return Ownership is passed back to the caller.
     */
    static FileVideoMediaMetadata* New();

    /**
     * Standard constructor for an immutable data object instance.
     *
     * @param[in] storage  The underlying data storage for this instance.
     */
    explicit FileVideoMediaMetadata(const Json::Value& storage);

    /**
     * Standard constructor for a mutable data object instance.
     *
     * @param[in] storage  The underlying data storage for this instance.
     */
    explicit FileVideoMediaMetadata(Json::Value* storage);

    /**
     * Standard destructor.
     */
    virtual ~FileVideoMediaMetadata();

    /**
     * Returns a string denoting the type of this data object.
     *
     * @return <code>google_drive_api::FileVideoMediaMetadata</code>
     */
    const StringPiece GetTypeName() const {
      return StringPiece("google_drive_api::FileVideoMediaMetadata");
    }

    /**
     * Determine if the '<code>durationMillis</code>' attribute was set.
     *
     * @return true if the '<code>durationMillis</code>' attribute was set.
     */
    bool has_duration_millis() const {
      return Storage().isMember("durationMillis");
    }

    /**
     * Clears the '<code>durationMillis</code>' attribute.
     */
    void clear_duration_millis() {
      MutableStorage()->removeMember("durationMillis");
    }


    /**
     * Get the value of the '<code>durationMillis</code>' attribute.
     */
    int64 get_duration_millis() const {
      const Json::Value& storage = Storage("durationMillis");
      return client::JsonValueToCppValueHelper<int64 >(storage);
    }

    /**
     * Change the '<code>durationMillis</code>' attribute.
     *
     * The duration of the video in milliseconds.
     *
     * @param[in] value The new value.
     */
    void set_duration_millis(int64 value) {
      client::SetJsonValueFromCppValueHelper<int64 >(
        value, MutableStorage("durationMillis"));
    }

    /**
     * Determine if the '<code>height</code>' attribute was set.
     *
     * @return true if the '<code>height</code>' attribute was set.
     */
    bool has_height() const {
      return Storage().isMember("height");
    }

    /**
     * Clears the '<code>height</code>' attribute.
     */
    void clear_height() {
      MutableStorage()->removeMember("height");
    }


    /**
     * Get the value of the '<code>height</code>' attribute.
     */
    int32 get_height() const {
      const Json::Value& storage = Storage("height");
      return client::JsonValueToCppValueHelper<int32 >(storage);
    }

    /**
     * Change the '<code>height</code>' attribute.
     *
     * The height of the video in pixels.
     *
     * @param[in] value The new value.
     */
    void set_height(int32 value) {
      client::SetJsonValueFromCppValueHelper<int32 >(
        value, MutableStorage("height"));
    }

    /**
     * Determine if the '<code>width</code>' attribute was set.
     *
     * @return true if the '<code>width</code>' attribute was set.
     */
    bool has_width() const {
      return Storage().isMember("width");
    }

    /**
     * Clears the '<code>width</code>' attribute.
     */
    void clear_width() {
      MutableStorage()->removeMember("width");
    }


    /**
     * Get the value of the '<code>width</code>' attribute.
     */
    int32 get_width() const {
      const Json::Value& storage = Storage("width");
      return client::JsonValueToCppValueHelper<int32 >(storage);
    }

    /**
     * Change the '<code>width</code>' attribute.
     *
     * The width of the video in pixels.
     *
     * @param[in] value The new value.
     */
    void set_width(int32 value) {
      client::SetJsonValueFromCppValueHelper<int32 >(
        value, MutableStorage("width"));
    }

   private:
    void operator=(const FileVideoMediaMetadata&);
  };  // FileVideoMediaMetadata
  /**
   * Creates a new default instance.
   *
   * @return Ownership is passed back to the caller.
   */
  static File* New();

  /**
   * Standard constructor for an immutable data object instance.
   *
   * @param[in] storage  The underlying data storage for this instance.
   */
  explicit File(const Json::Value& storage);

  /**
   * Standard constructor for a mutable data object instance.
   *
   * @param[in] storage  The underlying data storage for this instance.
   */
  explicit File(Json::Value* storage);

  /**
   * Standard destructor.
   */
  virtual ~File();

  /**
   * Returns a string denoting the type of this data object.
   *
   * @return <code>google_drive_api::File</code>
   */
  const StringPiece GetTypeName() const {
    return StringPiece("google_drive_api::File");
  }

  /**
   * Determine if the '<code>alternateLink</code>' attribute was set.
   *
   * @return true if the '<code>alternateLink</code>' attribute was set.
   */
  bool has_alternate_link() const {
    return Storage().isMember("alternateLink");
  }

  /**
   * Clears the '<code>alternateLink</code>' attribute.
   */
  void clear_alternate_link() {
    MutableStorage()->removeMember("alternateLink");
  }


  /**
   * Get the value of the '<code>alternateLink</code>' attribute.
   */
  const StringPiece get_alternate_link() const {
    const Json::Value& v = Storage("alternateLink");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>alternateLink</code>' attribute.
   *
   * A link for opening the file in a relevant Google editor or viewer.
   *
   * @param[in] value The new value.
   */
  void set_alternate_link(const StringPiece& value) {
    *MutableStorage("alternateLink") = value.data();
  }

  /**
   * Determine if the '<code>appDataContents</code>' attribute was set.
   *
   * @return true if the '<code>appDataContents</code>' attribute was set.
   */
  bool has_app_data_contents() const {
    return Storage().isMember("appDataContents");
  }

  /**
   * Clears the '<code>appDataContents</code>' attribute.
   */
  void clear_app_data_contents() {
    MutableStorage()->removeMember("appDataContents");
  }


  /**
   * Get the value of the '<code>appDataContents</code>' attribute.
   */
  bool get_app_data_contents() const {
    const Json::Value& storage = Storage("appDataContents");
    return client::JsonValueToCppValueHelper<bool >(storage);
  }

  /**
   * Change the '<code>appDataContents</code>' attribute.
   *
   * Whether this file is in the Application Data folder.
   *
   * @param[in] value The new value.
   */
  void set_app_data_contents(bool value) {
    client::SetJsonValueFromCppValueHelper<bool >(
      value, MutableStorage("appDataContents"));
  }

  /**
   * Determine if the '<code>copyable</code>' attribute was set.
   *
   * @return true if the '<code>copyable</code>' attribute was set.
   */
  bool has_copyable() const {
    return Storage().isMember("copyable");
  }

  /**
   * Clears the '<code>copyable</code>' attribute.
   */
  void clear_copyable() {
    MutableStorage()->removeMember("copyable");
  }


  /**
   * Get the value of the '<code>copyable</code>' attribute.
   */
  bool get_copyable() const {
    const Json::Value& storage = Storage("copyable");
    return client::JsonValueToCppValueHelper<bool >(storage);
  }

  /**
   * Change the '<code>copyable</code>' attribute.
   *
   * Whether the file can be copied by the current user.
   *
   * @param[in] value The new value.
   */
  void set_copyable(bool value) {
    client::SetJsonValueFromCppValueHelper<bool >(
      value, MutableStorage("copyable"));
  }

  /**
   * Determine if the '<code>createdDate</code>' attribute was set.
   *
   * @return true if the '<code>createdDate</code>' attribute was set.
   */
  bool has_created_date() const {
    return Storage().isMember("createdDate");
  }

  /**
   * Clears the '<code>createdDate</code>' attribute.
   */
  void clear_created_date() {
    MutableStorage()->removeMember("createdDate");
  }


  /**
   * Get the value of the '<code>createdDate</code>' attribute.
   */
  client::DateTime get_created_date() const {
    const Json::Value& storage = Storage("createdDate");
    return client::JsonValueToCppValueHelper<client::DateTime >(storage);
  }

  /**
   * Change the '<code>createdDate</code>' attribute.
   *
   * Create time for this file (formatted RFC 3339 timestamp).
   *
   * @param[in] value The new value.
   */
  void set_created_date(client::DateTime value) {
    client::SetJsonValueFromCppValueHelper<client::DateTime >(
      value, MutableStorage("createdDate"));
  }

  /**
   * Determine if the '<code>defaultOpenWithLink</code>' attribute was set.
   *
   * @return true if the '<code>defaultOpenWithLink</code>' attribute was set.
   */
  bool has_default_open_with_link() const {
    return Storage().isMember("defaultOpenWithLink");
  }

  /**
   * Clears the '<code>defaultOpenWithLink</code>' attribute.
   */
  void clear_default_open_with_link() {
    MutableStorage()->removeMember("defaultOpenWithLink");
  }


  /**
   * Get the value of the '<code>defaultOpenWithLink</code>' attribute.
   */
  const StringPiece get_default_open_with_link() const {
    const Json::Value& v = Storage("defaultOpenWithLink");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>defaultOpenWithLink</code>' attribute.
   *
   * A link to open this file with the user's default app for this file. Only
   * populated when the drive.apps.readonly scope is used.
   *
   * @param[in] value The new value.
   */
  void set_default_open_with_link(const StringPiece& value) {
    *MutableStorage("defaultOpenWithLink") = value.data();
  }

  /**
   * Determine if the '<code>description</code>' attribute was set.
   *
   * @return true if the '<code>description</code>' attribute was set.
   */
  bool has_description() const {
    return Storage().isMember("description");
  }

  /**
   * Clears the '<code>description</code>' attribute.
   */
  void clear_description() {
    MutableStorage()->removeMember("description");
  }


  /**
   * Get the value of the '<code>description</code>' attribute.
   */
  const StringPiece get_description() const {
    const Json::Value& v = Storage("description");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>description</code>' attribute.
   *
   * A short description of the file.
   *
   * @param[in] value The new value.
   */
  void set_description(const StringPiece& value) {
    *MutableStorage("description") = value.data();
  }

  /**
   * Determine if the '<code>downloadUrl</code>' attribute was set.
   *
   * @return true if the '<code>downloadUrl</code>' attribute was set.
   */
  bool has_download_url() const {
    return Storage().isMember("downloadUrl");
  }

  /**
   * Clears the '<code>downloadUrl</code>' attribute.
   */
  void clear_download_url() {
    MutableStorage()->removeMember("downloadUrl");
  }


  /**
   * Get the value of the '<code>downloadUrl</code>' attribute.
   */
  const StringPiece get_download_url() const {
    const Json::Value& v = Storage("downloadUrl");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>downloadUrl</code>' attribute.
   *
   * Short lived download URL for the file. This is only populated for files
   * with content stored in Drive.
   *
   * @param[in] value The new value.
   */
  void set_download_url(const StringPiece& value) {
    *MutableStorage("downloadUrl") = value.data();
  }

  /**
   * Determine if the '<code>editable</code>' attribute was set.
   *
   * @return true if the '<code>editable</code>' attribute was set.
   */
  bool has_editable() const {
    return Storage().isMember("editable");
  }

  /**
   * Clears the '<code>editable</code>' attribute.
   */
  void clear_editable() {
    MutableStorage()->removeMember("editable");
  }


  /**
   * Get the value of the '<code>editable</code>' attribute.
   */
  bool get_editable() const {
    const Json::Value& storage = Storage("editable");
    return client::JsonValueToCppValueHelper<bool >(storage);
  }

  /**
   * Change the '<code>editable</code>' attribute.
   *
   * Whether the file can be edited by the current user.
   *
   * @param[in] value The new value.
   */
  void set_editable(bool value) {
    client::SetJsonValueFromCppValueHelper<bool >(
      value, MutableStorage("editable"));
  }

  /**
   * Determine if the '<code>embedLink</code>' attribute was set.
   *
   * @return true if the '<code>embedLink</code>' attribute was set.
   */
  bool has_embed_link() const {
    return Storage().isMember("embedLink");
  }

  /**
   * Clears the '<code>embedLink</code>' attribute.
   */
  void clear_embed_link() {
    MutableStorage()->removeMember("embedLink");
  }


  /**
   * Get the value of the '<code>embedLink</code>' attribute.
   */
  const StringPiece get_embed_link() const {
    const Json::Value& v = Storage("embedLink");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>embedLink</code>' attribute.
   *
   * A link for embedding the file.
   *
   * @param[in] value The new value.
   */
  void set_embed_link(const StringPiece& value) {
    *MutableStorage("embedLink") = value.data();
  }

  /**
   * Determine if the '<code>etag</code>' attribute was set.
   *
   * @return true if the '<code>etag</code>' attribute was set.
   */
  bool has_etag() const {
    return Storage().isMember("etag");
  }

  /**
   * Clears the '<code>etag</code>' attribute.
   */
  void clear_etag() {
    MutableStorage()->removeMember("etag");
  }


  /**
   * Get the value of the '<code>etag</code>' attribute.
   */
  const StringPiece get_etag() const {
    const Json::Value& v = Storage("etag");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>etag</code>' attribute.
   *
   * ETag of the file.
   *
   * @param[in] value The new value.
   */
  void set_etag(const StringPiece& value) {
    *MutableStorage("etag") = value.data();
  }

  /**
   * Determine if the '<code>explicitlyTrashed</code>' attribute was set.
   *
   * @return true if the '<code>explicitlyTrashed</code>' attribute was set.
   */
  bool has_explicitly_trashed() const {
    return Storage().isMember("explicitlyTrashed");
  }

  /**
   * Clears the '<code>explicitlyTrashed</code>' attribute.
   */
  void clear_explicitly_trashed() {
    MutableStorage()->removeMember("explicitlyTrashed");
  }


  /**
   * Get the value of the '<code>explicitlyTrashed</code>' attribute.
   */
  bool get_explicitly_trashed() const {
    const Json::Value& storage = Storage("explicitlyTrashed");
    return client::JsonValueToCppValueHelper<bool >(storage);
  }

  /**
   * Change the '<code>explicitlyTrashed</code>' attribute.
   *
   * Whether this file has been explicitly trashed, as opposed to recursively
   * trashed. This will only be populated if the file is trashed.
   *
   * @param[in] value The new value.
   */
  void set_explicitly_trashed(bool value) {
    client::SetJsonValueFromCppValueHelper<bool >(
      value, MutableStorage("explicitlyTrashed"));
  }

  /**
   * Determine if the '<code>exportLinks</code>' attribute was set.
   *
   * @return true if the '<code>exportLinks</code>' attribute was set.
   */
  bool has_export_links() const {
    return Storage().isMember("exportLinks");
  }

  /**
   * Clears the '<code>exportLinks</code>' attribute.
   */
  void clear_export_links() {
    MutableStorage()->removeMember("exportLinks");
  }


  /**
   * Get a reference to the value of the '<code>exportLinks</code>' attribute.
   */
  const client::JsonCppAssociativeArray<string > get_export_links() const {
     const Json::Value& storage = Storage("exportLinks");
    return client::JsonValueToCppValueHelper<client::JsonCppAssociativeArray<string > >(storage);
  }

  /**
   * Gets a reference to a mutable value of the '<code>exportLinks</code>'
   * property.
   *
   * Links for exporting Google Docs to specific formats.
   *
   * @return The result can be modified to change the attribute value.
   */
  client::JsonCppAssociativeArray<string > mutable_exportLinks() {
    Json::Value* storage = MutableStorage("exportLinks");
    return client::JsonValueToMutableCppValueHelper<client::JsonCppAssociativeArray<string > >(storage);
  }

  /**
   * Determine if the '<code>fileExtension</code>' attribute was set.
   *
   * @return true if the '<code>fileExtension</code>' attribute was set.
   */
  bool has_file_extension() const {
    return Storage().isMember("fileExtension");
  }

  /**
   * Clears the '<code>fileExtension</code>' attribute.
   */
  void clear_file_extension() {
    MutableStorage()->removeMember("fileExtension");
  }


  /**
   * Get the value of the '<code>fileExtension</code>' attribute.
   */
  const StringPiece get_file_extension() const {
    const Json::Value& v = Storage("fileExtension");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>fileExtension</code>' attribute.
   *
   * The file extension used when downloading this file. This field is read
   * only. To set the extension, include it in the title when creating the file.
   * This is only populated for files with content stored in Drive.
   *
   * @param[in] value The new value.
   */
  void set_file_extension(const StringPiece& value) {
    *MutableStorage("fileExtension") = value.data();
  }

  /**
   * Determine if the '<code>fileSize</code>' attribute was set.
   *
   * @return true if the '<code>fileSize</code>' attribute was set.
   */
  bool has_file_size() const {
    return Storage().isMember("fileSize");
  }

  /**
   * Clears the '<code>fileSize</code>' attribute.
   */
  void clear_file_size() {
    MutableStorage()->removeMember("fileSize");
  }


  /**
   * Get the value of the '<code>fileSize</code>' attribute.
   */
  int64 get_file_size() const {
    const Json::Value& storage = Storage("fileSize");
    return client::JsonValueToCppValueHelper<int64 >(storage);
  }

  /**
   * Change the '<code>fileSize</code>' attribute.
   *
   * The size of the file in bytes. This is only populated for files with
   * content stored in Drive.
   *
   * @param[in] value The new value.
   */
  void set_file_size(int64 value) {
    client::SetJsonValueFromCppValueHelper<int64 >(
      value, MutableStorage("fileSize"));
  }

  /**
   * Determine if the '<code>headRevisionId</code>' attribute was set.
   *
   * @return true if the '<code>headRevisionId</code>' attribute was set.
   */
  bool has_head_revision_id() const {
    return Storage().isMember("headRevisionId");
  }

  /**
   * Clears the '<code>headRevisionId</code>' attribute.
   */
  void clear_head_revision_id() {
    MutableStorage()->removeMember("headRevisionId");
  }


  /**
   * Get the value of the '<code>headRevisionId</code>' attribute.
   */
  const StringPiece get_head_revision_id() const {
    const Json::Value& v = Storage("headRevisionId");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>headRevisionId</code>' attribute.
   *
   * The ID of the file's head revision. This will only be populated for files
   * with content stored in Drive.
   *
   * @param[in] value The new value.
   */
  void set_head_revision_id(const StringPiece& value) {
    *MutableStorage("headRevisionId") = value.data();
  }

  /**
   * Determine if the '<code>iconLink</code>' attribute was set.
   *
   * @return true if the '<code>iconLink</code>' attribute was set.
   */
  bool has_icon_link() const {
    return Storage().isMember("iconLink");
  }

  /**
   * Clears the '<code>iconLink</code>' attribute.
   */
  void clear_icon_link() {
    MutableStorage()->removeMember("iconLink");
  }


  /**
   * Get the value of the '<code>iconLink</code>' attribute.
   */
  const StringPiece get_icon_link() const {
    const Json::Value& v = Storage("iconLink");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>iconLink</code>' attribute.
   *
   * A link to the file's icon.
   *
   * @param[in] value The new value.
   */
  void set_icon_link(const StringPiece& value) {
    *MutableStorage("iconLink") = value.data();
  }

  /**
   * Determine if the '<code>id</code>' attribute was set.
   *
   * @return true if the '<code>id</code>' attribute was set.
   */
  bool has_id() const {
    return Storage().isMember("id");
  }

  /**
   * Clears the '<code>id</code>' attribute.
   */
  void clear_id() {
    MutableStorage()->removeMember("id");
  }


  /**
   * Get the value of the '<code>id</code>' attribute.
   */
  const StringPiece get_id() const {
    const Json::Value& v = Storage("id");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>id</code>' attribute.
   *
   * The ID of the file.
   *
   * @param[in] value The new value.
   */
  void set_id(const StringPiece& value) {
    *MutableStorage("id") = value.data();
  }

  /**
   * Determine if the '<code>imageMediaMetadata</code>' attribute was set.
   *
   * @return true if the '<code>imageMediaMetadata</code>' attribute was set.
   */
  bool has_image_media_metadata() const {
    return Storage().isMember("imageMediaMetadata");
  }

  /**
   * Clears the '<code>imageMediaMetadata</code>' attribute.
   */
  void clear_image_media_metadata() {
    MutableStorage()->removeMember("imageMediaMetadata");
  }


  /**
   * Get a reference to the value of the '<code>imageMediaMetadata</code>'
   * attribute.
   */
  const FileImageMediaMetadata get_image_media_metadata() const {
     const Json::Value& storage = Storage("imageMediaMetadata");
    return client::JsonValueToCppValueHelper<FileImageMediaMetadata >(storage);
  }

  /**
   * Gets a reference to a mutable value of the
   * '<code>imageMediaMetadata</code>' property.
   *
   * Metadata about image media. This will only be present for image types, and
   * its contents will depend on what can be parsed from the image content.
   *
   * @return The result can be modified to change the attribute value.
   */
  FileImageMediaMetadata mutable_imageMediaMetadata() {
    Json::Value* storage = MutableStorage("imageMediaMetadata");
    return client::JsonValueToMutableCppValueHelper<FileImageMediaMetadata >(storage);
  }

  /**
   * Determine if the '<code>indexableText</code>' attribute was set.
   *
   * @return true if the '<code>indexableText</code>' attribute was set.
   */
  bool has_indexable_text() const {
    return Storage().isMember("indexableText");
  }

  /**
   * Clears the '<code>indexableText</code>' attribute.
   */
  void clear_indexable_text() {
    MutableStorage()->removeMember("indexableText");
  }


  /**
   * Get a reference to the value of the '<code>indexableText</code>' attribute.
   */
  const FileIndexableText get_indexable_text() const {
     const Json::Value& storage = Storage("indexableText");
    return client::JsonValueToCppValueHelper<FileIndexableText >(storage);
  }

  /**
   * Gets a reference to a mutable value of the '<code>indexableText</code>'
   * property.
   *
   * Indexable text attributes for the file (can only be written).
   *
   * @return The result can be modified to change the attribute value.
   */
  FileIndexableText mutable_indexableText() {
    Json::Value* storage = MutableStorage("indexableText");
    return client::JsonValueToMutableCppValueHelper<FileIndexableText >(storage);
  }

  /**
   * Determine if the '<code>kind</code>' attribute was set.
   *
   * @return true if the '<code>kind</code>' attribute was set.
   */
  bool has_kind() const {
    return Storage().isMember("kind");
  }

  /**
   * Clears the '<code>kind</code>' attribute.
   */
  void clear_kind() {
    MutableStorage()->removeMember("kind");
  }


  /**
   * Get the value of the '<code>kind</code>' attribute.
   */
  const StringPiece get_kind() const {
    const Json::Value& v = Storage("kind");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>kind</code>' attribute.
   *
   * The type of file. This is always drive#file.
   *
   * @param[in] value The new value.
   */
  void set_kind(const StringPiece& value) {
    *MutableStorage("kind") = value.data();
  }

  /**
   * Determine if the '<code>labels</code>' attribute was set.
   *
   * @return true if the '<code>labels</code>' attribute was set.
   */
  bool has_labels() const {
    return Storage().isMember("labels");
  }

  /**
   * Clears the '<code>labels</code>' attribute.
   */
  void clear_labels() {
    MutableStorage()->removeMember("labels");
  }


  /**
   * Get a reference to the value of the '<code>labels</code>' attribute.
   */
  const FileLabels get_labels() const {
     const Json::Value& storage = Storage("labels");
    return client::JsonValueToCppValueHelper<FileLabels >(storage);
  }

  /**
   * Gets a reference to a mutable value of the '<code>labels</code>' property.
   *
   * A group of labels for the file.
   *
   * @return The result can be modified to change the attribute value.
   */
  FileLabels mutable_labels() {
    Json::Value* storage = MutableStorage("labels");
    return client::JsonValueToMutableCppValueHelper<FileLabels >(storage);
  }

  /**
   * Determine if the '<code>lastModifyingUser</code>' attribute was set.
   *
   * @return true if the '<code>lastModifyingUser</code>' attribute was set.
   */
  bool has_last_modifying_user() const {
    return Storage().isMember("lastModifyingUser");
  }

  /**
   * Clears the '<code>lastModifyingUser</code>' attribute.
   */
  void clear_last_modifying_user() {
    MutableStorage()->removeMember("lastModifyingUser");
  }


  /**
   * Get a reference to the value of the '<code>lastModifyingUser</code>'
   * attribute.
   */
  const User get_last_modifying_user() const {
     const Json::Value& storage = Storage("lastModifyingUser");
    return client::JsonValueToCppValueHelper<User >(storage);
  }

  /**
   * Gets a reference to a mutable value of the '<code>lastModifyingUser</code>'
   * property.
   *
   * The last user to modify this file.
   *
   * @return The result can be modified to change the attribute value.
   */
  User mutable_lastModifyingUser() {
    Json::Value* storage = MutableStorage("lastModifyingUser");
    return client::JsonValueToMutableCppValueHelper<User >(storage);
  }

  /**
   * Determine if the '<code>lastModifyingUserName</code>' attribute was set.
   *
   * @return true if the '<code>lastModifyingUserName</code>' attribute was set.
   */
  bool has_last_modifying_user_name() const {
    return Storage().isMember("lastModifyingUserName");
  }

  /**
   * Clears the '<code>lastModifyingUserName</code>' attribute.
   */
  void clear_last_modifying_user_name() {
    MutableStorage()->removeMember("lastModifyingUserName");
  }


  /**
   * Get the value of the '<code>lastModifyingUserName</code>' attribute.
   */
  const StringPiece get_last_modifying_user_name() const {
    const Json::Value& v = Storage("lastModifyingUserName");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>lastModifyingUserName</code>' attribute.
   *
   * Name of the last user to modify this file.
   *
   * @param[in] value The new value.
   */
  void set_last_modifying_user_name(const StringPiece& value) {
    *MutableStorage("lastModifyingUserName") = value.data();
  }

  /**
   * Determine if the '<code>lastViewedByMeDate</code>' attribute was set.
   *
   * @return true if the '<code>lastViewedByMeDate</code>' attribute was set.
   */
  bool has_last_viewed_by_me_date() const {
    return Storage().isMember("lastViewedByMeDate");
  }

  /**
   * Clears the '<code>lastViewedByMeDate</code>' attribute.
   */
  void clear_last_viewed_by_me_date() {
    MutableStorage()->removeMember("lastViewedByMeDate");
  }


  /**
   * Get the value of the '<code>lastViewedByMeDate</code>' attribute.
   */
  client::DateTime get_last_viewed_by_me_date() const {
    const Json::Value& storage = Storage("lastViewedByMeDate");
    return client::JsonValueToCppValueHelper<client::DateTime >(storage);
  }

  /**
   * Change the '<code>lastViewedByMeDate</code>' attribute.
   *
   * Last time this file was viewed by the user (formatted RFC 3339 timestamp).
   *
   * @param[in] value The new value.
   */
  void set_last_viewed_by_me_date(client::DateTime value) {
    client::SetJsonValueFromCppValueHelper<client::DateTime >(
      value, MutableStorage("lastViewedByMeDate"));
  }

  /**
   * Determine if the '<code>markedViewedByMeDate</code>' attribute was set.
   *
   * @return true if the '<code>markedViewedByMeDate</code>' attribute was set.
   */
  bool has_marked_viewed_by_me_date() const {
    return Storage().isMember("markedViewedByMeDate");
  }

  /**
   * Clears the '<code>markedViewedByMeDate</code>' attribute.
   */
  void clear_marked_viewed_by_me_date() {
    MutableStorage()->removeMember("markedViewedByMeDate");
  }


  /**
   * Get the value of the '<code>markedViewedByMeDate</code>' attribute.
   */
  client::DateTime get_marked_viewed_by_me_date() const {
    const Json::Value& storage = Storage("markedViewedByMeDate");
    return client::JsonValueToCppValueHelper<client::DateTime >(storage);
  }

  /**
   * Change the '<code>markedViewedByMeDate</code>' attribute.
   *
   * Time this file was explicitly marked viewed by the user (formatted RFC 3339
   * timestamp).
   *
   * @param[in] value The new value.
   */
  void set_marked_viewed_by_me_date(client::DateTime value) {
    client::SetJsonValueFromCppValueHelper<client::DateTime >(
      value, MutableStorage("markedViewedByMeDate"));
  }

  /**
   * Determine if the '<code>md5Checksum</code>' attribute was set.
   *
   * @return true if the '<code>md5Checksum</code>' attribute was set.
   */
  bool has_md5_checksum() const {
    return Storage().isMember("md5Checksum");
  }

  /**
   * Clears the '<code>md5Checksum</code>' attribute.
   */
  void clear_md5_checksum() {
    MutableStorage()->removeMember("md5Checksum");
  }


  /**
   * Get the value of the '<code>md5Checksum</code>' attribute.
   */
  const StringPiece get_md5_checksum() const {
    const Json::Value& v = Storage("md5Checksum");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>md5Checksum</code>' attribute.
   *
   * An MD5 checksum for the content of this file. This is populated only for
   * files with content stored in Drive.
   *
   * @param[in] value The new value.
   */
  void set_md5_checksum(const StringPiece& value) {
    *MutableStorage("md5Checksum") = value.data();
  }

  /**
   * Determine if the '<code>mimeType</code>' attribute was set.
   *
   * @return true if the '<code>mimeType</code>' attribute was set.
   */
  bool has_mime_type() const {
    return Storage().isMember("mimeType");
  }

  /**
   * Clears the '<code>mimeType</code>' attribute.
   */
  void clear_mime_type() {
    MutableStorage()->removeMember("mimeType");
  }


  /**
   * Get the value of the '<code>mimeType</code>' attribute.
   */
  const StringPiece get_mime_type() const {
    const Json::Value& v = Storage("mimeType");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>mimeType</code>' attribute.
   *
   * The MIME type of the file. This is only mutable on update when uploading
   * new content. This field can be left blank, and the mimetype will be
   * determined from the uploaded content's MIME type.
   *
   * @param[in] value The new value.
   */
  void set_mime_type(const StringPiece& value) {
    *MutableStorage("mimeType") = value.data();
  }

  /**
   * Determine if the '<code>modifiedByMeDate</code>' attribute was set.
   *
   * @return true if the '<code>modifiedByMeDate</code>' attribute was set.
   */
  bool has_modified_by_me_date() const {
    return Storage().isMember("modifiedByMeDate");
  }

  /**
   * Clears the '<code>modifiedByMeDate</code>' attribute.
   */
  void clear_modified_by_me_date() {
    MutableStorage()->removeMember("modifiedByMeDate");
  }


  /**
   * Get the value of the '<code>modifiedByMeDate</code>' attribute.
   */
  client::DateTime get_modified_by_me_date() const {
    const Json::Value& storage = Storage("modifiedByMeDate");
    return client::JsonValueToCppValueHelper<client::DateTime >(storage);
  }

  /**
   * Change the '<code>modifiedByMeDate</code>' attribute.
   *
   * Last time this file was modified by the user (formatted RFC 3339
   * timestamp). Note that setting modifiedDate will also update the
   * modifiedByMe date for the user which set the date.
   *
   * @param[in] value The new value.
   */
  void set_modified_by_me_date(client::DateTime value) {
    client::SetJsonValueFromCppValueHelper<client::DateTime >(
      value, MutableStorage("modifiedByMeDate"));
  }

  /**
   * Determine if the '<code>modifiedDate</code>' attribute was set.
   *
   * @return true if the '<code>modifiedDate</code>' attribute was set.
   */
  bool has_modified_date() const {
    return Storage().isMember("modifiedDate");
  }

  /**
   * Clears the '<code>modifiedDate</code>' attribute.
   */
  void clear_modified_date() {
    MutableStorage()->removeMember("modifiedDate");
  }


  /**
   * Get the value of the '<code>modifiedDate</code>' attribute.
   */
  client::DateTime get_modified_date() const {
    const Json::Value& storage = Storage("modifiedDate");
    return client::JsonValueToCppValueHelper<client::DateTime >(storage);
  }

  /**
   * Change the '<code>modifiedDate</code>' attribute.
   *
   * Last time this file was modified by anyone (formatted RFC 3339 timestamp).
   * This is only mutable on update when the setModifiedDate parameter is set.
   *
   * @param[in] value The new value.
   */
  void set_modified_date(client::DateTime value) {
    client::SetJsonValueFromCppValueHelper<client::DateTime >(
      value, MutableStorage("modifiedDate"));
  }

  /**
   * Determine if the '<code>openWithLinks</code>' attribute was set.
   *
   * @return true if the '<code>openWithLinks</code>' attribute was set.
   */
  bool has_open_with_links() const {
    return Storage().isMember("openWithLinks");
  }

  /**
   * Clears the '<code>openWithLinks</code>' attribute.
   */
  void clear_open_with_links() {
    MutableStorage()->removeMember("openWithLinks");
  }


  /**
   * Get a reference to the value of the '<code>openWithLinks</code>' attribute.
   */
  const client::JsonCppAssociativeArray<string > get_open_with_links() const {
     const Json::Value& storage = Storage("openWithLinks");
    return client::JsonValueToCppValueHelper<client::JsonCppAssociativeArray<string > >(storage);
  }

  /**
   * Gets a reference to a mutable value of the '<code>openWithLinks</code>'
   * property.
   *
   * A map of the id of each of the user's apps to a link to open this file with
   * that app. Only populated when the drive.apps.readonly scope is used.
   *
   * @return The result can be modified to change the attribute value.
   */
  client::JsonCppAssociativeArray<string > mutable_openWithLinks() {
    Json::Value* storage = MutableStorage("openWithLinks");
    return client::JsonValueToMutableCppValueHelper<client::JsonCppAssociativeArray<string > >(storage);
  }

  /**
   * Determine if the '<code>originalFilename</code>' attribute was set.
   *
   * @return true if the '<code>originalFilename</code>' attribute was set.
   */
  bool has_original_filename() const {
    return Storage().isMember("originalFilename");
  }

  /**
   * Clears the '<code>originalFilename</code>' attribute.
   */
  void clear_original_filename() {
    MutableStorage()->removeMember("originalFilename");
  }


  /**
   * Get the value of the '<code>originalFilename</code>' attribute.
   */
  const StringPiece get_original_filename() const {
    const Json::Value& v = Storage("originalFilename");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>originalFilename</code>' attribute.
   *
   * The original filename if the file was uploaded manually, or the original
   * title if the file was inserted through the API. Note that renames of the
   * title will not change the original filename. This will only be populated on
   * files with content stored in Drive.
   *
   * @param[in] value The new value.
   */
  void set_original_filename(const StringPiece& value) {
    *MutableStorage("originalFilename") = value.data();
  }

  /**
   * Determine if the '<code>ownerNames</code>' attribute was set.
   *
   * @return true if the '<code>ownerNames</code>' attribute was set.
   */
  bool has_owner_names() const {
    return Storage().isMember("ownerNames");
  }

  /**
   * Clears the '<code>ownerNames</code>' attribute.
   */
  void clear_owner_names() {
    MutableStorage()->removeMember("ownerNames");
  }


  /**
   * Get a reference to the value of the '<code>ownerNames</code>' attribute.
   */
  const client::JsonCppArray<string > get_owner_names() const {
     const Json::Value& storage = Storage("ownerNames");
    return client::JsonValueToCppValueHelper<client::JsonCppArray<string > >(storage);
  }

  /**
   * Gets a reference to a mutable value of the '<code>ownerNames</code>'
   * property.
   *
   * Name(s) of the owner(s) of this file.
   *
   * @return The result can be modified to change the attribute value.
   */
  client::JsonCppArray<string > mutable_ownerNames() {
    Json::Value* storage = MutableStorage("ownerNames");
    return client::JsonValueToMutableCppValueHelper<client::JsonCppArray<string > >(storage);
  }

  /**
   * Determine if the '<code>owners</code>' attribute was set.
   *
   * @return true if the '<code>owners</code>' attribute was set.
   */
  bool has_owners() const {
    return Storage().isMember("owners");
  }

  /**
   * Clears the '<code>owners</code>' attribute.
   */
  void clear_owners() {
    MutableStorage()->removeMember("owners");
  }


  /**
   * Get a reference to the value of the '<code>owners</code>' attribute.
   */
  const client::JsonCppArray<User > get_owners() const {
     const Json::Value& storage = Storage("owners");
    return client::JsonValueToCppValueHelper<client::JsonCppArray<User > >(storage);
  }

  /**
   * Gets a reference to a mutable value of the '<code>owners</code>' property.
   *
   * The owner(s) of this file.
   *
   * @return The result can be modified to change the attribute value.
   */
  client::JsonCppArray<User > mutable_owners() {
    Json::Value* storage = MutableStorage("owners");
    return client::JsonValueToMutableCppValueHelper<client::JsonCppArray<User > >(storage);
  }

  /**
   * Determine if the '<code>parents</code>' attribute was set.
   *
   * @return true if the '<code>parents</code>' attribute was set.
   */
  bool has_parents() const {
    return Storage().isMember("parents");
  }

  /**
   * Clears the '<code>parents</code>' attribute.
   */
  void clear_parents() {
    MutableStorage()->removeMember("parents");
  }


  /**
   * Get a reference to the value of the '<code>parents</code>' attribute.
   */
  const client::JsonCppArray<ParentReference > get_parents() const {
     const Json::Value& storage = Storage("parents");
    return client::JsonValueToCppValueHelper<client::JsonCppArray<ParentReference > >(storage);
  }

  /**
   * Gets a reference to a mutable value of the '<code>parents</code>' property.
   *
   * Collection of parent folders which contain this file.
   * Setting this field will put the file in all of the provided folders. On
   * insert, if no folders are provided, the file will be placed in the default
   * root folder.
   *
   * @return The result can be modified to change the attribute value.
   */
  client::JsonCppArray<ParentReference > mutable_parents() {
    Json::Value* storage = MutableStorage("parents");
    return client::JsonValueToMutableCppValueHelper<client::JsonCppArray<ParentReference > >(storage);
  }

  /**
   * Determine if the '<code>permissions</code>' attribute was set.
   *
   * @return true if the '<code>permissions</code>' attribute was set.
   */
  bool has_permissions() const {
    return Storage().isMember("permissions");
  }

  /**
   * Clears the '<code>permissions</code>' attribute.
   */
  void clear_permissions() {
    MutableStorage()->removeMember("permissions");
  }


  /**
   * Get a reference to the value of the '<code>permissions</code>' attribute.
   */
  const client::JsonCppArray<Permission > get_permissions() const {
     const Json::Value& storage = Storage("permissions");
    return client::JsonValueToCppValueHelper<client::JsonCppArray<Permission > >(storage);
  }

  /**
   * Gets a reference to a mutable value of the '<code>permissions</code>'
   * property.
   *
   * The list of permissions for users with access to this file.
   *
   * @return The result can be modified to change the attribute value.
   */
  client::JsonCppArray<Permission > mutable_permissions() {
    Json::Value* storage = MutableStorage("permissions");
    return client::JsonValueToMutableCppValueHelper<client::JsonCppArray<Permission > >(storage);
  }

  /**
   * Determine if the '<code>properties</code>' attribute was set.
   *
   * @return true if the '<code>properties</code>' attribute was set.
   */
  bool has_properties() const {
    return Storage().isMember("properties");
  }

  /**
   * Clears the '<code>properties</code>' attribute.
   */
  void clear_properties() {
    MutableStorage()->removeMember("properties");
  }


  /**
   * Get a reference to the value of the '<code>properties</code>' attribute.
   */
  const client::JsonCppArray<Property > get_properties() const {
     const Json::Value& storage = Storage("properties");
    return client::JsonValueToCppValueHelper<client::JsonCppArray<Property > >(storage);
  }

  /**
   * Gets a reference to a mutable value of the '<code>properties</code>'
   * property.
   *
   * The list of properties.
   *
   * @return The result can be modified to change the attribute value.
   */
  client::JsonCppArray<Property > mutable_properties() {
    Json::Value* storage = MutableStorage("properties");
    return client::JsonValueToMutableCppValueHelper<client::JsonCppArray<Property > >(storage);
  }

  /**
   * Determine if the '<code>quotaBytesUsed</code>' attribute was set.
   *
   * @return true if the '<code>quotaBytesUsed</code>' attribute was set.
   */
  bool has_quota_bytes_used() const {
    return Storage().isMember("quotaBytesUsed");
  }

  /**
   * Clears the '<code>quotaBytesUsed</code>' attribute.
   */
  void clear_quota_bytes_used() {
    MutableStorage()->removeMember("quotaBytesUsed");
  }


  /**
   * Get the value of the '<code>quotaBytesUsed</code>' attribute.
   */
  int64 get_quota_bytes_used() const {
    const Json::Value& storage = Storage("quotaBytesUsed");
    return client::JsonValueToCppValueHelper<int64 >(storage);
  }

  /**
   * Change the '<code>quotaBytesUsed</code>' attribute.
   *
   * The number of quota bytes used by this file.
   *
   * @param[in] value The new value.
   */
  void set_quota_bytes_used(int64 value) {
    client::SetJsonValueFromCppValueHelper<int64 >(
      value, MutableStorage("quotaBytesUsed"));
  }

  /**
   * Determine if the '<code>selfLink</code>' attribute was set.
   *
   * @return true if the '<code>selfLink</code>' attribute was set.
   */
  bool has_self_link() const {
    return Storage().isMember("selfLink");
  }

  /**
   * Clears the '<code>selfLink</code>' attribute.
   */
  void clear_self_link() {
    MutableStorage()->removeMember("selfLink");
  }


  /**
   * Get the value of the '<code>selfLink</code>' attribute.
   */
  const StringPiece get_self_link() const {
    const Json::Value& v = Storage("selfLink");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>selfLink</code>' attribute.
   *
   * A link back to this file.
   *
   * @param[in] value The new value.
   */
  void set_self_link(const StringPiece& value) {
    *MutableStorage("selfLink") = value.data();
  }

  /**
   * Determine if the '<code>shared</code>' attribute was set.
   *
   * @return true if the '<code>shared</code>' attribute was set.
   */
  bool has_shared() const {
    return Storage().isMember("shared");
  }

  /**
   * Clears the '<code>shared</code>' attribute.
   */
  void clear_shared() {
    MutableStorage()->removeMember("shared");
  }


  /**
   * Get the value of the '<code>shared</code>' attribute.
   */
  bool get_shared() const {
    const Json::Value& storage = Storage("shared");
    return client::JsonValueToCppValueHelper<bool >(storage);
  }

  /**
   * Change the '<code>shared</code>' attribute.
   *
   * Whether the file has been shared.
   *
   * @param[in] value The new value.
   */
  void set_shared(bool value) {
    client::SetJsonValueFromCppValueHelper<bool >(
      value, MutableStorage("shared"));
  }

  /**
   * Determine if the '<code>sharedWithMeDate</code>' attribute was set.
   *
   * @return true if the '<code>sharedWithMeDate</code>' attribute was set.
   */
  bool has_shared_with_me_date() const {
    return Storage().isMember("sharedWithMeDate");
  }

  /**
   * Clears the '<code>sharedWithMeDate</code>' attribute.
   */
  void clear_shared_with_me_date() {
    MutableStorage()->removeMember("sharedWithMeDate");
  }


  /**
   * Get the value of the '<code>sharedWithMeDate</code>' attribute.
   */
  client::DateTime get_shared_with_me_date() const {
    const Json::Value& storage = Storage("sharedWithMeDate");
    return client::JsonValueToCppValueHelper<client::DateTime >(storage);
  }

  /**
   * Change the '<code>sharedWithMeDate</code>' attribute.
   *
   * Time at which this file was shared with the user (formatted RFC 3339
   * timestamp).
   *
   * @param[in] value The new value.
   */
  void set_shared_with_me_date(client::DateTime value) {
    client::SetJsonValueFromCppValueHelper<client::DateTime >(
      value, MutableStorage("sharedWithMeDate"));
  }

  /**
   * Determine if the '<code>sharingUser</code>' attribute was set.
   *
   * @return true if the '<code>sharingUser</code>' attribute was set.
   */
  bool has_sharing_user() const {
    return Storage().isMember("sharingUser");
  }

  /**
   * Clears the '<code>sharingUser</code>' attribute.
   */
  void clear_sharing_user() {
    MutableStorage()->removeMember("sharingUser");
  }


  /**
   * Get a reference to the value of the '<code>sharingUser</code>' attribute.
   */
  const User get_sharing_user() const {
     const Json::Value& storage = Storage("sharingUser");
    return client::JsonValueToCppValueHelper<User >(storage);
  }

  /**
   * Gets a reference to a mutable value of the '<code>sharingUser</code>'
   * property.
   *
   * User that shared the item with the current user, if available.
   *
   * @return The result can be modified to change the attribute value.
   */
  User mutable_sharingUser() {
    Json::Value* storage = MutableStorage("sharingUser");
    return client::JsonValueToMutableCppValueHelper<User >(storage);
  }

  /**
   * Determine if the '<code>thumbnail</code>' attribute was set.
   *
   * @return true if the '<code>thumbnail</code>' attribute was set.
   */
  bool has_thumbnail() const {
    return Storage().isMember("thumbnail");
  }

  /**
   * Clears the '<code>thumbnail</code>' attribute.
   */
  void clear_thumbnail() {
    MutableStorage()->removeMember("thumbnail");
  }


  /**
   * Get a reference to the value of the '<code>thumbnail</code>' attribute.
   */
  const FileThumbnail get_thumbnail() const {
     const Json::Value& storage = Storage("thumbnail");
    return client::JsonValueToCppValueHelper<FileThumbnail >(storage);
  }

  /**
   * Gets a reference to a mutable value of the '<code>thumbnail</code>'
   * property.
   *
   * Thumbnail for the file. Only accepted on upload and for files that are not
   * already thumbnailed by Google.
   *
   * @return The result can be modified to change the attribute value.
   */
  FileThumbnail mutable_thumbnail() {
    Json::Value* storage = MutableStorage("thumbnail");
    return client::JsonValueToMutableCppValueHelper<FileThumbnail >(storage);
  }

  /**
   * Determine if the '<code>thumbnailLink</code>' attribute was set.
   *
   * @return true if the '<code>thumbnailLink</code>' attribute was set.
   */
  bool has_thumbnail_link() const {
    return Storage().isMember("thumbnailLink");
  }

  /**
   * Clears the '<code>thumbnailLink</code>' attribute.
   */
  void clear_thumbnail_link() {
    MutableStorage()->removeMember("thumbnailLink");
  }


  /**
   * Get the value of the '<code>thumbnailLink</code>' attribute.
   */
  const StringPiece get_thumbnail_link() const {
    const Json::Value& v = Storage("thumbnailLink");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>thumbnailLink</code>' attribute.
   *
   * A link to the file's thumbnail.
   *
   * @param[in] value The new value.
   */
  void set_thumbnail_link(const StringPiece& value) {
    *MutableStorage("thumbnailLink") = value.data();
  }

  /**
   * Determine if the '<code>title</code>' attribute was set.
   *
   * @return true if the '<code>title</code>' attribute was set.
   */
  bool has_title() const {
    return Storage().isMember("title");
  }

  /**
   * Clears the '<code>title</code>' attribute.
   */
  void clear_title() {
    MutableStorage()->removeMember("title");
  }


  /**
   * Get the value of the '<code>title</code>' attribute.
   */
  const StringPiece get_title() const {
    const Json::Value& v = Storage("title");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>title</code>' attribute.
   *
   * The title of this file.
   *
   * @param[in] value The new value.
   */
  void set_title(const StringPiece& value) {
    *MutableStorage("title") = value.data();
  }

  /**
   * Determine if the '<code>userPermission</code>' attribute was set.
   *
   * @return true if the '<code>userPermission</code>' attribute was set.
   */
  bool has_user_permission() const {
    return Storage().isMember("userPermission");
  }

  /**
   * Clears the '<code>userPermission</code>' attribute.
   */
  void clear_user_permission() {
    MutableStorage()->removeMember("userPermission");
  }


  /**
   * Get a reference to the value of the '<code>userPermission</code>'
   * attribute.
   */
  const Permission get_user_permission() const {
     const Json::Value& storage = Storage("userPermission");
    return client::JsonValueToCppValueHelper<Permission >(storage);
  }

  /**
   * Gets a reference to a mutable value of the '<code>userPermission</code>'
   * property.
   *
   * The permissions for the authenticated user on this file.
   *
   * @return The result can be modified to change the attribute value.
   */
  Permission mutable_userPermission() {
    Json::Value* storage = MutableStorage("userPermission");
    return client::JsonValueToMutableCppValueHelper<Permission >(storage);
  }

  /**
   * Determine if the '<code>version</code>' attribute was set.
   *
   * @return true if the '<code>version</code>' attribute was set.
   */
  bool has_version() const {
    return Storage().isMember("version");
  }

  /**
   * Clears the '<code>version</code>' attribute.
   */
  void clear_version() {
    MutableStorage()->removeMember("version");
  }


  /**
   * Get the value of the '<code>version</code>' attribute.
   */
  int64 get_version() const {
    const Json::Value& storage = Storage("version");
    return client::JsonValueToCppValueHelper<int64 >(storage);
  }

  /**
   * Change the '<code>version</code>' attribute.
   *
   * A monotonically increasing version number for the file. This reflects every
   * change made to the file on the server, even those not visible to the
   * requesting user.
   *
   * @param[in] value The new value.
   */
  void set_version(int64 value) {
    client::SetJsonValueFromCppValueHelper<int64 >(
      value, MutableStorage("version"));
  }

  /**
   * Determine if the '<code>videoMediaMetadata</code>' attribute was set.
   *
   * @return true if the '<code>videoMediaMetadata</code>' attribute was set.
   */
  bool has_video_media_metadata() const {
    return Storage().isMember("videoMediaMetadata");
  }

  /**
   * Clears the '<code>videoMediaMetadata</code>' attribute.
   */
  void clear_video_media_metadata() {
    MutableStorage()->removeMember("videoMediaMetadata");
  }


  /**
   * Get a reference to the value of the '<code>videoMediaMetadata</code>'
   * attribute.
   */
  const FileVideoMediaMetadata get_video_media_metadata() const {
     const Json::Value& storage = Storage("videoMediaMetadata");
    return client::JsonValueToCppValueHelper<FileVideoMediaMetadata >(storage);
  }

  /**
   * Gets a reference to a mutable value of the
   * '<code>videoMediaMetadata</code>' property.
   *
   * Metadata about video media. This will only be present for video types.
   *
   * @return The result can be modified to change the attribute value.
   */
  FileVideoMediaMetadata mutable_videoMediaMetadata() {
    Json::Value* storage = MutableStorage("videoMediaMetadata");
    return client::JsonValueToMutableCppValueHelper<FileVideoMediaMetadata >(storage);
  }

  /**
   * Determine if the '<code>webContentLink</code>' attribute was set.
   *
   * @return true if the '<code>webContentLink</code>' attribute was set.
   */
  bool has_web_content_link() const {
    return Storage().isMember("webContentLink");
  }

  /**
   * Clears the '<code>webContentLink</code>' attribute.
   */
  void clear_web_content_link() {
    MutableStorage()->removeMember("webContentLink");
  }


  /**
   * Get the value of the '<code>webContentLink</code>' attribute.
   */
  const StringPiece get_web_content_link() const {
    const Json::Value& v = Storage("webContentLink");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>webContentLink</code>' attribute.
   *
   * A link for downloading the content of the file in a browser using cookie
   * based authentication. In cases where the content is shared publicly, the
   * content can be downloaded without any credentials.
   *
   * @param[in] value The new value.
   */
  void set_web_content_link(const StringPiece& value) {
    *MutableStorage("webContentLink") = value.data();
  }

  /**
   * Determine if the '<code>webViewLink</code>' attribute was set.
   *
   * @return true if the '<code>webViewLink</code>' attribute was set.
   */
  bool has_web_view_link() const {
    return Storage().isMember("webViewLink");
  }

  /**
   * Clears the '<code>webViewLink</code>' attribute.
   */
  void clear_web_view_link() {
    MutableStorage()->removeMember("webViewLink");
  }


  /**
   * Get the value of the '<code>webViewLink</code>' attribute.
   */
  const StringPiece get_web_view_link() const {
    const Json::Value& v = Storage("webViewLink");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>webViewLink</code>' attribute.
   *
   * A link only available on public folders for viewing their static web assets
   * (HTML, CSS, JS, etc) via Google Drive's Website Hosting.
   *
   * @param[in] value The new value.
   */
  void set_web_view_link(const StringPiece& value) {
    *MutableStorage("webViewLink") = value.data();
  }

  /**
   * Determine if the '<code>writersCanShare</code>' attribute was set.
   *
   * @return true if the '<code>writersCanShare</code>' attribute was set.
   */
  bool has_writers_can_share() const {
    return Storage().isMember("writersCanShare");
  }

  /**
   * Clears the '<code>writersCanShare</code>' attribute.
   */
  void clear_writers_can_share() {
    MutableStorage()->removeMember("writersCanShare");
  }


  /**
   * Get the value of the '<code>writersCanShare</code>' attribute.
   */
  bool get_writers_can_share() const {
    const Json::Value& storage = Storage("writersCanShare");
    return client::JsonValueToCppValueHelper<bool >(storage);
  }

  /**
   * Change the '<code>writersCanShare</code>' attribute.
   *
   * Whether writers can share the document with other users.
   *
   * @param[in] value The new value.
   */
  void set_writers_can_share(bool value) {
    client::SetJsonValueFromCppValueHelper<bool >(
      value, MutableStorage("writersCanShare"));
  }

 private:
  void operator=(const File&);
};  // File
}  // namespace google_drive_api
#endif  // GOOGLE_DRIVE_API_FILE_H_
